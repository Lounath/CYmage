#include <stdio.h>
#include <stdlib.h>

struct BITMAP_header{
	char name[2]; //doit être ègale à BM car fichier bmp
	unsigned int size;
	int reserved; //pas important
	unsigned int image_offset;
};

struct DIB_header{
	unsigned int header_size;
	unsigned int width;
	unsigned int height;
	unsigned short int colorplanes;
	unsigned short int bitsperpixel;
	unsigned int compression;
	unsigned int image_size;
	unsigned int temp[4];
};

struct RGB{
	unsigned char blue;
	unsigned char green;
	unsigned char red;
};

struct Image{
	int height;
	int width;
	struct RGB **rgb;
};

struct Image readImage(FILE *fp, int height, int width){
	struct Image pic;
	int i;
	pic.rgb = (struct RGB**) malloc(height*sizeof(void*));
	pic.height = height;
	pic.width = width;
	for (i= height-1; i>=0; i--){
		pic.rgb[i] = (struct RGB*) malloc(width*sizeof(struct RGB));
		fread(pic.rgb[i], width, sizeof(struct RGB), fp);
	}
	
	return pic;
}

void freeImage(struct Image pic){
	int i;
	for (i= pic.height-1; i>=0; i--){
		free(pic.rgb[i]);
	}
	free(pic.rgb);
}
	
unsigned char gray(struct RGB rgb){
	return ((rgb.red) + (rgb.green) + (rgb.blue))/3;
}

void grayscale(struct Image pic){
	int i,j,temp;
	for (i = 0; i<pic.height; i++){
		for (j=0; j<pic.width; j++){
			temp=gray(pic.rgb[i][j]);
			pic.rgb[i][j].blue = temp;
			pic.rgb[i][j].green = temp;
			pic.rgb[i][j].red = temp;
		}
	}
}

void negatif(struct Image pic){
	int i,j,temp;
	for (i = 0; i<pic.height; i++){
		for (j=0; j<pic.width; j++){
			pic.rgb[i][j].blue = 255 - pic.rgb[i][j].blue;
			pic.rgb[i][j].green = 255 - pic.rgb[i][j].green;
			pic.rgb[i][j].red = 255 - pic.rgb[i][j].red;
		}
	}
}

int bWImage(struct BITMAP_header header, struct DIB_header dibheader, struct Image pic){
	int i;
	FILE *fpw= fopen("new.bmp","w");
	if (fpw == NULL) return 1;
	
	 negatif(pic);
	
	fwrite(header.name, 2, 1, fpw);
	fwrite(&header.size, 3*sizeof(int),1,fpw);
	fwrite(&dibheader, sizeof(struct DIB_header), 1, fpw);
	
	for (i= pic.height -1; i>=0; i--)
		fwrite(pic.rgb[i],pic.width,sizeof(struct RGB),fpw);
	fclose(fpw);
	return 0;
}

int openbmpfile(const char *fileName){
	FILE *fp = fopen(fileName,"rb");
	if (fp == NULL) return 1;
	
	struct BITMAP_header header;
	struct DIB_header dibheader;
	
	fread(header.name,2,1,fp);
	fread(&header.size, 3*sizeof(int),1,fp);
	//fread(&header,sizeof(struct BITMAP_header),1,fp);
	if ((header.name[0] != 'B') || (header.name[1] != 'M')){
		fclose(fp);
		return 1;
	}
	fread(&dibheader,sizeof(struct DIB_header),1,fp);
	if ((dibheader.header_size != 40) || (dibheader.compression != 0) || (dibheader.bitsperpixel != 24)){
		fclose(fp);
		return 1;
	}
	fseek(fp,header.image_offset , SEEK_SET);
	struct Image image = readImage(fp,dibheader.height,dibheader.width);
	bWImage(header, dibheader, image);
	
	fclose(fp);
	freeImage(image);
	return 0;
}
	

int main(){
	openbmpfile("imaget.bmp");
	return 0;
}
	
	
